---
icon: code
date: 2025-10-22
order: 2
category:
  - æ™ºèƒ½ä¼˜åŒ–ç®—æ³•
tag:
  - å¤šç›®æ ‡è¿›åŒ–ç®—æ³•
---

# å¤šç›®æ ‡é—ä¼ ç®—æ³•ï¼ˆMOGAï¼‰

**MOGAï¼ˆMulti-Objective Genetic Algorithmï¼‰** æ˜¯ Fonseca & Fleming äº 1993 å¹´æå‡ºçš„å¤šç›®æ ‡è¿›åŒ–ç®—æ³•ã€‚  
å®ƒåœ¨ç»å…¸é—ä¼ ç®—æ³•åŸºç¡€ä¸Šï¼Œé€šè¿‡ **Pareto æ”¯é…æ’åº + é€‚åº”åº¦å…±äº«æœºåˆ¶** å®ç°å¤šç›®æ ‡ä¼˜åŒ–ã€‚

---

## ğŸ§© ç®—æ³•æµç¨‹å›¾

```mermaid
graph TD
    A["å¼€å§‹"] --> B["åˆå§‹åŒ–ç§ç¾¤ P(0)"]
    B --> C["è®¡ç®—ç›®æ ‡å‡½æ•° f(x)"]
    C --> D["è®¡ç®— Pareto ç­‰çº§ r_i"]
    D --> E["è®¡ç®—å…±äº«é€‚åº”åº¦ Ï†'_i"]
    E --> F["é€‰æ‹©æ“ä½œï¼šè½®ç›˜èµŒæˆ–SUS"]
    F --> G["äº¤å‰ä¸å˜å¼‚äº§ç”Ÿå­ä»£"]
    G --> H["è¯„ä¼°å­ä»£ç›®æ ‡å€¼"]
    H --> I["åˆå¹¶çˆ¶ä»£ä¸å­ä»£"]
    I --> J["æ›´æ–°å¤–éƒ¨æ¡£æ¡ˆ Aï¼ˆéæ”¯é…é›†ï¼‰"]
    J --> K{"æ˜¯å¦æ»¡è¶³ç»ˆæ­¢æ¡ä»¶ï¼Ÿ"}
    K -->|å¦| D
    K -->|æ˜¯| L["è¾“å‡ºæ¡£æ¡ˆ Aï¼ˆPareto å‰æ²¿ï¼‰"]
    L --> M["ç»“æŸ"]
```

## ä¸€ã€ç®—æ³•åŸç†ä¸æ ¸å¿ƒæœºåˆ¶

### 1. Pareto æ”¯é…å…³ç³»

åœ¨å¤šç›®æ ‡ä¼˜åŒ–é—®é¢˜ä¸­ï¼Œæˆ‘ä»¬é€šå¸¸å¸Œæœ›åŒæ—¶æœ€å°åŒ–ï¼ˆæˆ–æœ€å¤§åŒ–ï¼‰å¤šä¸ªç›®æ ‡å‡½æ•°ï¼š

$$
\min_{x \in \Omega} F(x) = [f_1(x), f_2(x), \dots, f_m(x)]
$$

å…¶ä¸­ï¼š
- $\Omega$ æ˜¯å¯è¡Œè§£ç©ºé—´ï¼›
- $F(x)$ æ˜¯ç›®æ ‡å‘é‡ã€‚

å¯¹äºä¸¤ä¸ªè§£ $x_a, x_b \in \Omega$ï¼Œå®šä¹‰ **Pareto æ”¯é…ï¼ˆPareto dominanceï¼‰** å…³ç³»ï¼š

$$
x_a \prec x_b \iff
\begin{cases}
\forall k \in \{1,\dots,m\},\ f_k(x_a) \le f_k(x_b), \\
\exists k \in \{1,\dots,m\},\ f_k(x_a) < f_k(x_b)
\end{cases}
$$

å³ $x_a$ åœ¨æ‰€æœ‰ç›®æ ‡ä¸Šä¸åŠ£äº $x_b$ï¼Œä¸”è‡³å°‘åœ¨ä¸€ä¸ªç›®æ ‡ä¸Šä¼˜äº $x_b$ã€‚

è‹¥ä¸å­˜åœ¨ä»»ä½•å…¶ä»–è§£æ”¯é… $x^\ast$ï¼Œåˆ™ç§° $x^\ast$ ä¸º **Pareto æœ€ä¼˜è§£ï¼ˆPareto optimal solutionï¼‰**ï¼Œ  
æ‰€æœ‰æ­¤ç±»è§£çš„é›†åˆç§°ä¸º **Pareto æœ€ä¼˜é›†ï¼ˆPareto setï¼‰**ï¼Œå…¶ç›®æ ‡ç©ºé—´å¯¹åº”ä¸º **Pareto å‰æ²¿ï¼ˆPareto frontï¼‰**ã€‚

---

### 2. ç­‰çº§åˆ†é…ï¼ˆPareto Rankï¼‰

MOGA ä½¿ç”¨ **æ”¯é…æ¬¡æ•°æ’åæ³•ï¼ˆDominance Count Rankingï¼‰** æ¥è¡¡é‡æ¯ä¸ªä¸ªä½“çš„ä¼˜åŠ£ç¨‹åº¦ã€‚

è®¾ç§ç¾¤ä¸­å…±æœ‰ $N$ ä¸ªä¸ªä½“ï¼Œç¬¬ $i$ ä¸ªä¸ªä½“è¢«å¤šå°‘ä¸ªä¸ªä½“æ”¯é…ï¼Œåˆ™å®ƒçš„ç­‰çº§å®šä¹‰ä¸ºï¼š

$$
r_i = 1 + \left|\{\, j \mid F_j \prec F_i \,\}\right|
$$

- è‹¥ä¸ªä½“ $i$ æ²¡æœ‰è¢«ä»»ä½•ä¸ªä½“æ”¯é…ï¼Œåˆ™ $r_i = 1$ï¼›
- è‹¥å®ƒè¢«ä¸¤ä¸ªä¸ªä½“æ”¯é…ï¼Œåˆ™ $r_i = 3$ï¼Œä»¥æ­¤ç±»æ¨ã€‚

å› æ­¤ï¼Œ$r_i$ è¶Šå°ä»£è¡¨ä¸ªä½“è¶Šä¼˜ã€‚

---

### 3. ç­‰çº§é€‚åº”åº¦åˆ†é…ï¼ˆRank-based Fitness Assignmentï¼‰

å¾—åˆ°æ‰€æœ‰ä¸ªä½“çš„ç­‰çº§ $r_i$ åï¼Œä¸ºäº†å°†ç­‰çº§è½¬åŒ–ä¸ºé€‰æ‹©æ¦‚ç‡ï¼ŒMOGA ä½¿ç”¨çº¿æ€§ç¼©æ”¾çš„é€‚åº”åº¦ï¼š

$$
\phi_i = \phi_{\max} - \frac{\phi_{\max} - \phi_{\min}}{r_{\max} - 1} (r_i - 1)
$$

å…¶ä¸­ï¼š
- $\phi_{\max}$ ä¸ $\phi_{\min}$ åˆ†åˆ«ä¸ºæœ€é«˜ä¸æœ€ä½é€‚åº”åº¦ï¼ˆå¸¸å– $\phi_{\max}=2, \phi_{\min}=0$ï¼‰ï¼›
- $r_{\max}$ ä¸ºæœ€å¤§ç­‰çº§ã€‚

è¿™æ ·ï¼š
- ç­‰çº§æœ€ä½ï¼ˆæœ€ä¼˜ï¼‰çš„ä¸ªä½“å¾—åˆ°æœ€å¤§é€‚åº”åº¦ï¼›
- ç­‰çº§æœ€é«˜ï¼ˆæœ€åŠ£ï¼‰çš„ä¸ªä½“å¾—åˆ°æœ€å°é€‚åº”åº¦ã€‚

é€šè¿‡è¿™ç§æ–¹å¼ï¼Œé¿å…äº†ç›´æ¥å°†å¤šç›®æ ‡å‡½æ•°å‹ç¼©ä¸ºå•ç›®æ ‡å‡½æ•°æ‰€å¼•å…¥çš„åå·®é—®é¢˜ã€‚

---

### 4. é€‚åº”åº¦å…±äº«ï¼ˆFitness Sharingï¼‰

åœ¨å¤šç›®æ ‡ä¼˜åŒ–ä¸­ï¼Œè‹¥åªè€ƒè™‘é€‚åº”åº¦å¤§å°ï¼Œç®—æ³•å¯èƒ½ä¼šåœ¨æŸä¸€åŒºåŸŸèšé›†ï¼Œå¤±å»å¤šæ ·æ€§ã€‚  
MOGA å¼•å…¥äº† **é€‚åº”åº¦å…±äº«æœºåˆ¶**ï¼Œé€šè¿‡åœ¨ç›®æ ‡ç©ºé—´ä¸­æµ‹é‡ä¸ªä½“ä¹‹é—´çš„â€œè·ç¦»â€æ¥å¹³è¡¡å¯†åº¦åˆ†å¸ƒã€‚

é¦–å…ˆå®šä¹‰å…±äº«å‡½æ•°ï¼ˆSharing Functionï¼‰ï¼š

$$
\operatorname{sh}(d_{ij}) =
\begin{cases}
1 - \left(\dfrac{d_{ij}}{\sigma_{\text{share}}}\right)^{\alpha}, & d_{ij} < \sigma_{\text{share}} \\
0, & \text{å¦åˆ™}
\end{cases}
$$

å…¶ä¸­ï¼š
- $d_{ij}$ ä¸ºä¸ªä½“ $i$ ä¸ $j$ çš„è·ç¦»ï¼›
- $\sigma_{\text{share}}$ ä¸ºå…±äº«åŠå¾„ï¼›
- $\alpha$ æ§åˆ¶å‡½æ•°å½¢çŠ¶ï¼ˆå¸¸å– 1 æˆ– 2ï¼‰ã€‚

ä¸ªä½“ $i$ çš„é‚»åŸŸå¯†åº¦å®šä¹‰ä¸ºï¼š

$$
m_i = \sum_{j=1}^{N} \operatorname{sh}(d_{ij})
$$

å†å¯¹å…¶é€‚åº”åº¦è¿›è¡Œâ€œå¹³æ»‘â€ï¼š

$$
\phi'_i = \frac{\phi_i}{m_i}
$$

å› æ­¤ï¼Œè‹¥ä¸ªä½“å¤„äºå¯†é›†åŒºåŸŸï¼ˆ$m_i$ è¾ƒå¤§ï¼‰ï¼Œåˆ™ $\phi'_i$ ä¼šè¢«â€œå‰Šå¼±â€ï¼Œä»è€Œé™ä½è¢«é€‰ä¸­æ¦‚ç‡ï¼Œ  
ä»¥æ­¤é¼“åŠ±ç§ç¾¤æ²¿ Pareto å‰æ²¿å‡åŒ€åˆ†å¸ƒã€‚

---

### 5. å…±äº«è·ç¦»åº¦é‡

ä¸€èˆ¬ä½¿ç”¨ç›®æ ‡ç©ºé—´ä¸­çš„æ¬§æ°è·ç¦»ï¼š

$$
d_{ij} = \sqrt{ \sum_{k=1}^{m} \left( \tilde{f}_k(i) - \tilde{f}_k(j) \right)^2 }
$$

å…¶ä¸­ $\tilde{f}_k$ è¡¨ç¤ºç›®æ ‡å½’ä¸€åŒ–å€¼ï¼š

$$
\tilde{f}_k(i) = \frac{f_k(i) - f_k^{\min}}{f_k^{\max} - f_k^{\min}}
$$

é€šè¿‡å½’ä¸€åŒ–å¤„ç†ï¼Œä¿è¯ä¸åŒé‡çº²çš„ç›®æ ‡ä¹‹é—´å…·æœ‰å¯æ¯”æ€§ã€‚

---

## äºŒã€å®Œæ•´ç®—æ³•æµç¨‹ï¼ˆå¸¦ç²¾è‹±æ¡£æ¡ˆï¼‰

MOGA çš„å®Œæ•´æ‰§è¡Œæ­¥éª¤å¦‚ä¸‹ï¼š

1. **åˆå§‹åŒ–ç§ç¾¤**ï¼šéšæœºç”Ÿæˆ $N$ ä¸ªä½“ $P^{(0)}$ã€‚  
2. **è®¡ç®—ç›®æ ‡å‡½æ•°**ï¼šæ±‚å–æ¯ä¸ªä¸ªä½“çš„ $F_i = [f_1(x_i), f_2(x_i), ...]$ã€‚  
3. **Pareto æ’åº**ï¼šè®¡ç®—æ¯ä¸ªä¸ªä½“çš„ç­‰çº§ $r_i$ã€‚  
4. **é€‚åº”åº¦è®¡ç®—**ï¼šæŒ‰ç­‰çº§è®¡ç®— $\phi_i$ï¼Œå†ç”¨å…±äº«å‡½æ•°ä¿®æ­£ä¸º $\phi'_i$ã€‚  
5. **é€‰æ‹©æ“ä½œ**ï¼šæ ¹æ® $\phi'_i$ çš„æ¦‚ç‡è¿›è¡Œçˆ¶ä»£é€‰æ‹©ï¼ˆå¸¸ç”¨è½®ç›˜èµŒæˆ– SUSï¼‰ã€‚  
6. **äº¤å‰ä¸å˜å¼‚**ï¼šåº”ç”¨æ¨¡æ‹ŸäºŒè¿›åˆ¶äº¤å‰ï¼ˆSBXï¼‰å’Œå¤šé¡¹å¼å˜å¼‚ç”Ÿæˆå­ä»£ã€‚  
7. **è®¡ç®—å­ä»£ç›®æ ‡å€¼**ã€‚  
8. **ç²¾è‹±ä¿ç•™**ï¼šå°†çˆ¶ä»£ã€å­ä»£ä¸å½“å‰å¤–éƒ¨æ¡£æ¡ˆ $A$ åˆå¹¶ï¼Œ  
   å–éæ”¯é…é›†æ›´æ–° $A$ï¼ˆè‹¥è¶…é™åˆ™æŒ‰æ‹¥æŒ¤è·ç¦»è£å‰ªï¼‰ã€‚  
9. **å½¢æˆä¸‹ä¸€ä»£**ï¼šä»åˆå¹¶é›†ä¸­æŒ‰å…±äº«é€‚åº”åº¦é€‰å‡ºæ–°ä¸€ä»£ $P^{(t+1)}$ã€‚  
10. **ç»ˆæ­¢åˆ¤æ–­**ï¼šè‹¥è¾¾åˆ°è¿­ä»£æ¬¡æ•°æˆ–æ”¶æ•›æ¡ä»¶ï¼Œè¾“å‡ºæ¡£æ¡ˆ $A$ã€‚

æœ€ç»ˆè¾“å‡ºçš„ $A$ å³ä¸ºè¿‘ä¼¼çš„ **Pareto å‰æ²¿**ã€‚

---

## ä¸‰ã€å‚æ•°è®¾ç½®å»ºè®®

| å‚æ•° | å«ä¹‰ | å»ºè®®å–å€¼ |
| ---- | ---- | -------- |
| $N$ | ç§ç¾¤è§„æ¨¡ | 100â€“200 |
| $T$ | æœ€å¤§è¿­ä»£ä»£æ•° | 200â€“500 |
| $\sigma_{\text{share}}$ | å…±äº«åŠå¾„ | 0.05â€“0.2 |
| $\alpha$ | å…±äº«æŒ‡æ•° | 1 æˆ– 2 |
| $p_c$ | äº¤å‰æ¦‚ç‡ | 0.9 |
| $p_m$ | å˜å¼‚æ¦‚ç‡ | $1/n$ |
| $\eta_c$ | SBX äº¤å‰å‚æ•° | 10â€“20 |
| $\eta_m$ | å¤šé¡¹å¼å˜å¼‚å‚æ•° | 20 |

---

## å››ã€ä»£ç å®ç°ï¼ˆZDT1 ç¤ºä¾‹ï¼‰

::: code-tabs#MOGA

@tab Python

```python
"""
===============================================================
å¤šç›®æ ‡é—ä¼ ç®—æ³• MOGA (Multi-Objective Genetic Algorithm)
ç¤ºä¾‹é—®é¢˜ï¼šZDT1
ä¾èµ–ï¼šnumpy
===============================================================
"""

import numpy as np
from dataclasses import dataclass

# éšæœºæ•°ç”Ÿæˆå™¨
rng = np.random.default_rng()

# ===============================================================
# ZDT1 æµ‹è¯•å‡½æ•°ï¼ˆä¸¤ç›®æ ‡æœ€å°åŒ–é—®é¢˜ï¼‰
# ===============================================================
def zdt1(x):
    """
    è¾“å…¥ï¼š
        x : ndarray, ä¸ªä½“çš„å†³ç­–å˜é‡å‘é‡
    è¾“å‡ºï¼š
        np.array([f1, f2]) : ä¸¤ä¸ªç›®æ ‡å€¼
    """
    f1 = x[0]
    g  = 1 + 9 * np.mean(x[1:])          # ç¬¬äºŒç›®æ ‡æ§åˆ¶é¡¹
    h  = 1 - np.sqrt(f1 / g)
    f2 = g * h
    return np.array([f1, f2])


# ===============================================================
# æ”¯é…å…³ç³»åˆ¤æ–­å‡½æ•°
# ===============================================================
def dominates(fi, fj):
    """
    åˆ¤æ–­ä¸ªä½“ i æ˜¯å¦æ”¯é…ä¸ªä½“ j
    æ¡ä»¶ï¼šæ‰€æœ‰ç›®æ ‡ä¸åŠ£ä¸”è‡³å°‘ä¸€ä¸ªç›®æ ‡æ›´ä¼˜
    """
    return np.all(fi <= fj) and np.any(fi < fj)


# ===============================================================
# Pareto æ’åè®¡ç®—ï¼ˆæ”¯é…æ¬¡æ•°æ³•ï¼‰
# ===============================================================
def pareto_rank(F):
    """
    è¾“å…¥ï¼š
        F : (N, m) ç›®æ ‡çŸ©é˜µ
    è¾“å‡ºï¼š
        r : (N,) æ¯ä¸ªä¸ªä½“çš„ç­‰çº§ï¼Œè¶Šå°è¶Šä¼˜
    """
    N = len(F)
    r = np.ones(N, dtype=int)
    for i in range(N):
        for j in range(N):
            if i != j and dominates(F[j], F[i]):
                r[i] += 1  # è¢«æ”¯é…ä¸€æ¬¡ç­‰çº§åŠ 1
    return r


# ===============================================================
# ç›®æ ‡å½’ä¸€åŒ–
# ===============================================================
def normalize_objectives(F):
    """
    å°†å„ç›®æ ‡å€¼çº¿æ€§å½’ä¸€åŒ–åˆ° [0,1] åŒºé—´
    """
    fmin, fmax = F.min(0), F.max(0)
    return (F - fmin) / np.maximum(fmax - fmin, 1e-12)


# ===============================================================
# è®¡ç®—é‚»åŸŸå¯†åº¦ (m_i)
# ===============================================================
def niche_count(F, sigma=0.1, alpha=1):
    """
    è¾“å…¥ï¼š
        F : ç›®æ ‡çŸ©é˜µ (N, m)
        sigma : å…±äº«åŠå¾„
        alpha : å…±äº«æŒ‡æ•°
    è¾“å‡ºï¼š
        m : æ¯ä¸ªä¸ªä½“çš„é‚»åŸŸå¯†åº¦
    """
    Fn = normalize_objectives(F)
    N = len(F)
    m = np.zeros(N)
    for i in range(N):
        d = np.linalg.norm(Fn[i] - Fn, axis=1)  # æ¬§æ°è·ç¦»
        sh = np.maximum(0, 1 - (d / sigma) ** alpha)  # å…±äº«å‡½æ•°
        sh[d >= sigma] = 0
        m[i] = sh.sum()
    return np.maximum(m, 1)  # é˜²æ­¢é™¤é›¶


# ===============================================================
# è®¡ç®—å…±äº«é€‚åº”åº¦
# ===============================================================
def shared_fitness(F, r, sigma=0.1, alpha=1):
    """
    è¾“å…¥ï¼š
        F : ç›®æ ‡çŸ©é˜µ
        r : Pareto ç­‰çº§
    è¾“å‡ºï¼š
        phi' : ä¿®æ­£åçš„é€‚åº”åº¦å€¼
    """
    rmax = r.max()
    # ç­‰çº§é€‚åº”åº¦æ˜ å°„
    phi = 2 - (2 - 0) * (r - 1) / (rmax - 1) if rmax > 1 else np.ones_like(r) * 2
    # é‚»åŸŸå…±äº«ä¿®æ­£
    return phi / niche_count(F, sigma, alpha)


# ===============================================================
# éšæœºå‡åŒ€é‡‡æ ·é€‰æ‹© (SUS)
# ===============================================================
def sus_select(weights, n):
    """
    è¾“å…¥ï¼š
        weights : ä¸ªä½“é€‚åº”åº¦
        n : é€‰æ‹©ä¸ªæ•°
    è¾“å‡ºï¼š
        ç´¢å¼•æ•°ç»„ (è¢«é€‰ä¸­çš„ä¸ªä½“ç´¢å¼•)
    """
    w = np.maximum(weights, 0)
    w /= w.sum()
    cum = np.cumsum(w)
    step, start = 1 / n, np.random.random() / n
    points = start + step * np.arange(n)
    return np.searchsorted(cum, points)


# ===============================================================
# æ¨¡æ‹ŸäºŒè¿›åˆ¶äº¤å‰ (SBX)
# ===============================================================
def sbx_crossover(p1, p2, eta=15, pc=0.9):
    """
    è¾“å…¥ï¼š
        p1, p2 : çˆ¶ä»£ä¸ªä½“
        eta : åˆ†å¸ƒå‚æ•° (è¶Šå¤§å­ä»£è¶Šæ¥è¿‘çˆ¶ä»£)
        pc : äº¤å‰æ¦‚ç‡
    è¾“å‡ºï¼š
        c1, c2 : äº¤å‰åçš„ä¸¤ä¸ªå­ä»£
    """
    c1, c2 = p1.copy(), p2.copy()
    if np.random.random() < pc:
        for i in range(len(p1)):
            if np.random.random() < 0.5:
                x1, x2 = sorted([p1[i], p2[i]])
                u = np.random.random()
                beta = 1 + 2 * (x1) / (x2 - x1)
                alpha = 2 - beta ** (-(eta + 1))
                if u <= 1 / alpha:
                    betaq = (u * alpha) ** (1 / (eta + 1))
                else:
                    betaq = (1 / (2 - u * alpha)) ** (1 / (eta + 1))
                # è®¡ç®—å­ä»£
                c1[i] = 0.5 * ((x1 + x2) - betaq * (x2 - x1))
                c2[i] = 0.5 * ((x1 + x2) + betaq * (x2 - x1))
    # ä¿è¯å˜é‡èŒƒå›´åœ¨ [0,1]
    return np.clip(c1, 0, 1), np.clip(c2, 0, 1)


# ===============================================================
# å¤šé¡¹å¼å˜å¼‚ç®—å­
# ===============================================================
def poly_mutation(x, eta=20, pm=None):
    """
    è¾“å…¥ï¼š
        x : ä¸ªä½“å‘é‡
        eta : åˆ†å¸ƒå‚æ•°
        pm : å˜å¼‚æ¦‚ç‡ (é»˜è®¤ 1/n)
    è¾“å‡ºï¼š
        å˜å¼‚åçš„ä¸ªä½“
    """
    n = len(x)
    pm = 1 / n if pm is None else pm
    y = x.copy()
    for i in range(n):
        if np.random.random() < pm:
            u = np.random.random()
            if u < 0.5:
                delta = (2 * u) ** (1 / (eta + 1)) - 1
            else:
                delta = 1 - (2 * (1 - u)) ** (1 / (eta + 1))
            y[i] += delta
    return np.clip(y, 0, 1)


# ===============================================================
# é…ç½®å‚æ•°ç»“æ„ä½“
# ===============================================================
@dataclass
class MOGAConfig:
    pop_size: int = 100        # ç§ç¾¤è§„æ¨¡
    dim: int = 30              # å†³ç­–å˜é‡ç»´åº¦
    n_gen: int = 200           # æœ€å¤§è¿­ä»£ä»£æ•°
    sigma_share: float = 0.1   # å…±äº«åŠå¾„
    alpha_share: float = 1.0   # å…±äº«æŒ‡æ•°
    pc: float = 0.9            # äº¤å‰æ¦‚ç‡
    pm: float = None           # å˜å¼‚æ¦‚ç‡ï¼ˆè‹¥Noneåˆ™1/nï¼‰
    eta_c: int = 15            # SBXäº¤å‰å‚æ•°
    eta_m: int = 20            # å¤šé¡¹å¼å˜å¼‚å‚æ•°


# ===============================================================
# MOGA ä¸»å‡½æ•°
# ===============================================================
def moga(problem, cfg):
    """
    MOGA ä¸»å¾ªç¯
    è¾“å…¥ï¼š
        problem : ç›®æ ‡å‡½æ•°
        cfg : å‚æ•°é…ç½®å¯¹è±¡ MOGAConfig
    è¾“å‡ºï¼š
        Q : æœ€ç»ˆç§ç¾¤çŸ©é˜µ
        F : å¯¹åº”ç›®æ ‡å‡½æ•°å€¼çŸ©é˜µ
    """
    N, n = cfg.pop_size, cfg.dim
    # ---------- åˆå§‹åŒ– ----------
    P = np.random.rand(N, n)                       # åˆå§‹åŒ–ç§ç¾¤
    F = np.array([problem(x) for x in P])          # è®¡ç®—ç›®æ ‡å€¼

    # ---------- ä¸»å¾ªç¯ ----------
    for gen in range(cfg.n_gen):
        # 1. Pareto æ’å
        r = pareto_rank(F)

        # 2. è®¡ç®—å…±äº«é€‚åº”åº¦
        fit = shared_fitness(F, r, cfg.sigma_share, cfg.alpha_share)

        # 3. é€‰æ‹©æ“ä½œ
        parents = P[sus_select(fit, N)]

        # 4. äº¤å‰ä¸å˜å¼‚
        Q = []
        for i in range(0, N, 2):
            c1, c2 = sbx_crossover(
                parents[i],
                parents[(i + 1) % N],
                eta=cfg.eta_c
            )
            c1 = poly_mutation(c1, eta=cfg.eta_m)
            c2 = poly_mutation(c2, eta=cfg.eta_m)
            Q += [c1, c2]
        Q = np.array(Q)[:N]                        # æ§åˆ¶æ•°é‡
        F = np.array([problem(x) for x in Q])      # è®¡ç®—æ–°ç›®æ ‡å€¼

        # æ¯ 50 ä»£æ‰“å°ä¸€æ¬¡è¿›åº¦
        if gen % 50 == 0:
            print(f"Generation {gen}/{cfg.n_gen} finished.")

    return Q, F


# ===============================================================
# ä¸»ç¨‹åºå…¥å£
# ===============================================================
if __name__ == "__main__":
    cfg = MOGAConfig()             # ä½¿ç”¨é»˜è®¤å‚æ•°
    X, F = moga(zdt1, cfg)         # è¿è¡Œç®—æ³•
    print("Pareto å‰æ²¿æ ·æœ¬æ•°ï¼š", len(X))
    print("å‰ 5 ä¸ªç›®æ ‡å€¼æ ·æœ¬ï¼š\n", F[:5])
```

@tab MATLAB

```matlab
% ============================================================
% MOGAï¼ˆMulti-Objective Genetic Algorithmï¼Œå¤šç›®æ ‡é—ä¼ ç®—æ³•ï¼‰
% ç¤ºä¾‹é—®é¢˜ï¼šZDT1
% ============================================================

function moga_demo
    % ===================== å‚æ•°é…ç½® =====================
    cfg.pop_size = 100;        % ç§ç¾¤è§„æ¨¡ N
    cfg.dim = 30;              % å†³ç­–å˜é‡ç»´åº¦ n
    cfg.n_gen = 200;           % æœ€å¤§è¿­ä»£ä»£æ•°
    cfg.sigma_share = 0.1;     % å…±äº«åŠå¾„ Ïƒ_share
    cfg.alpha_share = 1.0;     % å…±äº«æŒ‡æ•° Î±
    cfg.pc = 0.9;              % äº¤å‰æ¦‚ç‡
    cfg.pm = 1 / cfg.dim;      % å˜å¼‚æ¦‚ç‡
    cfg.eta_c = 15;            % SBXäº¤å‰å‚æ•°
    cfg.eta_m = 20;            % å¤šé¡¹å¼å˜å¼‚å‚æ•°

    % ===================== ç›®æ ‡å‡½æ•° =====================
    problem = @zdt1;  % é‡‡ç”¨ ZDT1 æµ‹è¯•å‡½æ•°

    % ===================== è¿è¡Œç®—æ³• =====================
    [P, F] = moga(problem, cfg);

    % ===================== ç»˜åˆ¶ Pareto å‰æ²¿ =====================
    scatter(F(:,1), F(:,2), 20, 'filled');
    xlabel('f_1'); ylabel('f_2'); grid on;
    title('MOGA åœ¨ ZDT1 ä¸Šçš„ Pareto å‰æ²¿');
end


% ============================================================
% ZDT1 æµ‹è¯•å‡½æ•°ï¼ˆä¸¤ç›®æ ‡æœ€å°åŒ–é—®é¢˜ï¼‰
% ============================================================
function f = zdt1(x)
    f1 = x(1);
    g  = 1 + 9 * mean(x(2:end));
    h  = 1 - sqrt(f1 / g);
    f2 = g * h;
    f = [f1, f2];
end


% ============================================================
% ä¸»ç®—æ³•å‡½æ•°ï¼šMOGA ä¸»å¾ªç¯
% ============================================================
function [P, F] = moga(problem, cfg)
    % è¾“å…¥:
    %   problem: ç›®æ ‡å‡½æ•°å¥æŸ„
    %   cfg: å‚æ•°ç»“æ„ä½“ï¼ˆå«Nã€äº¤å‰ç‡ç­‰ï¼‰
    % è¾“å‡º:
    %   P: æœ€ç»ˆç§ç¾¤çŸ©é˜µ (N Ã— n)
    %   F: å¯¹åº”ç›®æ ‡å‡½æ•°å€¼ (N Ã— m)

    % ---------- åˆå§‹åŒ– ----------
    N = cfg.pop_size;
    n = cfg.dim;
    P = rand(N, n);                 % ç§ç¾¤åˆå§‹åŒ– [0,1]^n
    F = evalF(problem, P);          % è®¡ç®—ç›®æ ‡å‡½æ•°å€¼

    % ---------- è¿­ä»£æœç´¢ ----------
    for gen = 1:cfg.n_gen
        % --- 1. è®¡ç®— Pareto ç­‰çº§ ---
        r = pareto_rank(F);

        % --- 2. è®¡ç®—å…±äº«é€‚åº”åº¦ ---
        fit = shared_fit(F, r, cfg.sigma_share, cfg.alpha_share);

        % --- 3. é€‰æ‹©æ“ä½œï¼ˆSUSï¼‰ ---
        parents = P(sus_select(fit, N), :);

        % --- 4. äº¤å‰ä¸å˜å¼‚ ---
        Q = zeros(N, n);
        for i = 1:2:N
            % SBX äº¤å‰äº§ç”Ÿä¸¤ä¸ªå­ä»£
            [c1, c2] = sbx(parents(i,:), ...
                           parents(mod(i, N) + 1, :), ...
                           cfg.eta_c, cfg.pc);
            % å¤šé¡¹å¼å˜å¼‚
            c1 = poly_mut(c1, cfg.eta_m, cfg.pm);
            c2 = poly_mut(c2, cfg.eta_m, cfg.pm);
            Q(i,:) = c1;
            Q(i+1,:) = c2;
        end

        % --- 5. è¯„ä¼°æ–°ç§ç¾¤ç›®æ ‡å€¼ ---
        F = evalF(problem, Q);
        P = Q;  % æ›´æ–°ç§ç¾¤

        % ï¼ˆå¯é€‰ï¼‰æ˜¾ç¤ºè¿­ä»£è¿›åº¦
        if mod(gen, 50) == 0
            fprintf('è¿­ä»£ %d / %d å®Œæˆ\n', gen, cfg.n_gen);
        end
    end
end


% ============================================================
% è®¡ç®—ç§ç¾¤çš„ç›®æ ‡å‡½æ•°å€¼
% ============================================================
function F = evalF(problem, P)
    % è¾“å…¥: P (NÃ—n)
    % è¾“å‡º: F (NÃ—m)
    N = size(P, 1);
    F = zeros(N, 2);
    for i = 1:N
        F(i,:) = problem(P(i,:));
    end
end


% ============================================================
% Pareto æ’åè®¡ç®—å‡½æ•°
% æ”¯é…æ¬¡æ•°æ’åæ³• (Dominance Count Ranking)
% ============================================================
function r = pareto_rank(F)
    % è¾“å…¥: F (NÃ—m)
    % è¾“å‡º: r (NÃ—1)
    N = size(F,1);
    r = ones(N,1);
    for i = 1:N
        for j = 1:N
            if i ~= j && all(F(j,:) <= F(i,:)) && any(F(j,:) < F(i,:))
                r(i) = r(i) + 1;  % è¢«æ”¯é…ä¸€æ¬¡åˆ™ç­‰çº§ +1
            end
        end
    end
end


% ============================================================
% é€‚åº”åº¦å…±äº«æœºåˆ¶
% æ ¹æ®ä¸ªä½“å¯†åº¦ä¿®æ­£é€‚åº”åº¦å€¼ï¼Œä¿æŒè§£çš„å¤šæ ·æ€§
% ============================================================
function phi = shared_fit(F, r, sigma, alpha)
    % è¾“å…¥:
    %   F: ç›®æ ‡å€¼çŸ©é˜µ (NÃ—m)
    %   r: ç­‰çº§å‘é‡
    %   sigma, alpha: å…±äº«å‚æ•°
    % è¾“å‡º:
    %   phi: ä¿®æ­£åçš„é€‚åº”åº¦

    % ---- 1. ç­‰çº§é€‚åº”åº¦åˆ†é… ----
    rmax = max(r);
    phi = 2 - (2 - 0) * (r - 1) / (rmax - 1);

    % ---- 2. ç›®æ ‡å½’ä¸€åŒ– ----
    Fn = normalizeF(F);

    % ---- 3. è®¡ç®—é‚»åŸŸå¯†åº¦ m_i ----
    N = size(F, 1);
    m = zeros(N, 1);
    for i = 1:N
        d = sqrt(sum((Fn - Fn(i,:)).^2, 2));  % æ¬§æ°è·ç¦»
        sh = max(0, 1 - (d / sigma).^alpha);  % å…±äº«å‡½æ•°
        sh(d >= sigma) = 0;
        m(i) = sum(sh);
    end
    m(m == 0) = 1;  % é˜²æ­¢é™¤é›¶

    % ---- 4. ä¿®æ­£é€‚åº”åº¦ ----
    phi = phi ./ m;
end


% ============================================================
% ç›®æ ‡å½’ä¸€åŒ–
% ============================================================
function Fn = normalizeF(F)
    % è¾“å…¥: F (NÃ—m)
    % è¾“å‡º: å½’ä¸€åŒ–ç›®æ ‡çŸ©é˜µ
    fmin = min(F);
    fmax = max(F);
    Fn = (F - fmin) ./ (fmax - fmin + 1e-12);
end


% ============================================================
% SUSï¼ˆStochastic Universal Samplingï¼‰é€‰æ‹©ç®—å­
% ============================================================
function idx = sus_select(w, n)
    % è¾“å…¥:
    %   w: é€‚åº”åº¦å‘é‡
    %   n: é€‰å–æ•°é‡
    % è¾“å‡º:
    %   idx: è¢«é€‰ä¸­çš„ç´¢å¼•

    w = w / sum(w);
    cum = cumsum(w);
    step = 1 / n;
    start = rand * step;
    pts = start + step * (0:n-1);
    idx = arrayfun(@(p) find(cum >= p, 1), pts).';
end


% ============================================================
% æ¨¡æ‹ŸäºŒè¿›åˆ¶äº¤å‰ (SBX)
% ============================================================
function [c1, c2] = sbx(p1, p2, eta, pc)
    % è¾“å…¥:
    %   p1, p2: çˆ¶ä»£ä¸ªä½“
    %   eta: åˆ†å¸ƒæŒ‡æ•°
    %   pc: äº¤å‰æ¦‚ç‡
    % è¾“å‡º:
    %   c1, c2: ä¸¤ä¸ªå­ä»£ä¸ªä½“

    c1 = p1;
    c2 = p2;
    if rand < pc
        for i = 1:length(p1)
            if rand < 0.5
                x1 = min(p1(i), p2(i));
                x2 = max(p1(i), p2(i));
                u = rand;
                beta = 1 + 2 * (x1) / (x2 - x1);
                alpha = 2 - beta^(-(eta + 1));
                if u <= 1 / alpha
                    betaq = (u * alpha)^(1 / (eta + 1));
                else
                    betaq = (1 / (2 - u * alpha))^(1 / (eta + 1));
                end
                c1(i) = 0.5 * ((x1 + x2) - betaq * (x2 - x1));
                c2(i) = 0.5 * ((x1 + x2) + betaq * (x2 - x1));
            end
        end
    end
    % è¾¹ç•Œè£å‰ªï¼Œä¿æŒåœ¨ [0,1]
    c1 = max(min(c1, 1), 0);
    c2 = max(min(c2, 1), 0);
end


% ============================================================
% å¤šé¡¹å¼å˜å¼‚ç®—å­
% ============================================================
function y = poly_mut(x, eta, pm)
    % è¾“å…¥:
    %   x: ä¸ªä½“å‘é‡
    %   eta: å¤šé¡¹å¼åˆ†å¸ƒå‚æ•°
    %   pm: å˜å¼‚æ¦‚ç‡
    % è¾“å‡º:
    %   y: å˜å¼‚åçš„ä¸ªä½“

    y = x;
    for i = 1:length(x)
        if rand < pm
            u = rand;
            if u < 0.5
                delta = (2 * u)^(1 / (eta + 1)) - 1;
            else
                delta = 1 - (2 * (1 - u))^(1 / (eta + 1));
            end
            y(i) = y(i) + delta;
        end
    end
    % è¾¹ç•Œè£å‰ª
    y = max(min(y, 1), 0);
end

```

:::

---

## äº”ã€æ€»ç»“ä¸æ€è€ƒ

- MOGA å°† **Pareto æ”¯é…å…³ç³»** èå…¥é—ä¼ ç®—æ³•ï¼Œå®ç°å¤šç›®æ ‡çš„åŒæ—¶ä¼˜åŒ–ï¼›
- é€šè¿‡ **å…±äº«é€‚åº”åº¦æœºåˆ¶** ç»´æŒè§£çš„å¤šæ ·æ€§ï¼›
- ç¼ºç‚¹æ˜¯å¤æ‚åº¦è¾ƒé«˜ï¼Œä¸º $O(mN^2)$ï¼›
- åç»­ç®—æ³•ï¼ˆå¦‚ **NSGA-II**ï¼‰åœ¨å…¶åŸºç¡€ä¸Šä¼˜åŒ–äº†éæ”¯é…æ’åºå’Œç²¾è‹±ä¿ç•™æœºåˆ¶ï¼Œå¤§å¹…æå‡äº†æ€§èƒ½ä¸ç¨³å®šæ€§ã€‚

---

