import{_ as t,c as e,d as l,e as i,a,r as p,o as r}from"./app-Pg0_E5sd.js";const m={};function h(o,s){const n=p("Mermaid");return r(),e("div",null,[s[0]||(s[0]=l(`<h1 id="可变邻域搜索-vns" tabindex="-1"><a class="header-anchor" href="#可变邻域搜索-vns"><span>可变邻域搜索 (VNS)</span></a></h1><h2 id="_1-概念简介" tabindex="-1"><a class="header-anchor" href="#_1-概念简介"><span>1. 概念简介</span></a></h2><p><strong>VNS（Variable Neighborhood Search，可变邻域搜索）</strong> 是一种元启发式算法，通过系统性地改变邻域结构来摆脱局部最优，从而找到更优解。</p><p>它依赖两个核心观察：</p><ol><li><strong>局部最优依赖邻域定义</strong>：不同邻域下的局部最优不同。</li><li><strong>全局最优往往在某个邻域中是局部最优</strong>：系统探索多个邻域有助于发现全局更优解。</li></ol><hr><h2 id="_2-算法思想与框架" tabindex="-1"><a class="header-anchor" href="#_2-算法思想与框架"><span>2. 算法思想与框架</span></a></h2><h3 id="_2-1-核心步骤" tabindex="-1"><a class="header-anchor" href="#_2-1-核心步骤"><span>2.1 核心步骤</span></a></h3><ol><li><strong>扰动（Shaking）</strong>：从当前邻域中随机产生新解以跳出局部最优。</li><li><strong>局部搜索（Local Search）</strong>：对扰动后的解进行优化。</li><li><strong>邻域切换（Neighborhood Change）</strong>： <ul><li>若找到更优解 → 回到最小邻域</li><li>否则 → 进入下一个更大的邻域</li></ul></li></ol><h3 id="_2-2-基本框架伪代码" tabindex="-1"><a class="header-anchor" href="#_2-2-基本框架伪代码"><span>2.2 基本框架伪代码</span></a></h3><div class="language-text line-numbers-mode" data-highlighter="shiki" data-ext="text" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-text"><span class="line"><span>Repeat until stop condition:</span></span>
<span class="line"><span>    i = 1</span></span>
<span class="line"><span>    while i ≤ k:</span></span>
<span class="line"><span>        x&#39; = Shaking(x, N_i)</span></span>
<span class="line"><span>        x&#39;&#39; = LocalSearch(x&#39;)</span></span>
<span class="line"><span>        if f(x&#39;&#39;) &lt; f(x):</span></span>
<span class="line"><span>            x = x&#39;&#39;</span></span>
<span class="line"><span>            i = 1</span></span>
<span class="line"><span>        else:</span></span>
<span class="line"><span>            i = i + 1</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_3-邻域设计-vns-的关键" tabindex="-1"><a class="header-anchor" href="#_3-邻域设计-vns-的关键"><span>3. 邻域设计（VNS 的关键）</span></a></h2><p>邻域（Neighborhood）的选择与组织是 VNS 成败的核心。<br> 好的邻域结构应满足：</p><ul><li>便于搜索（可枚举或可随机生成）</li><li>能有效跳出局部最优</li><li>复杂度与解质量之间取得平衡</li></ul><h3 id="_3-1-基于规模的邻域-常用于路径类问题" tabindex="-1"><a class="header-anchor" href="#_3-1-基于规模的邻域-常用于路径类问题"><span>3.1 基于规模的邻域（常用于路径类问题）</span></a></h3><ul><li><strong>2-opt</strong>：交换路径中两段的连接方式</li><li><strong>Or-opt</strong>：移动连续 1～3 个节点到新位置</li><li><strong>3-opt</strong>：移除三条边并重新连接</li></ul><p>示例邻域序列：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mn>1</mn></msub><mo>=</mo><mtext>2-opt</mtext><mo separator="true">,</mo><mtext>  </mtext><msub><mi>N</mi><mn>2</mn></msub><mo>=</mo><mtext>Or-opt</mtext><mo separator="true">,</mo><mtext>  </mtext><msub><mi>N</mi><mn>3</mn></msub><mo>=</mo><mtext>3-opt</mtext></mrow><annotation encoding="application/x-tex">N_1 = \\text{2-opt},\\; N_2 = \\text{Or-opt},\\; N_3 = \\text{3-opt}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord text"><span class="mord">2-opt</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord text"><span class="mord">Or-opt</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord text"><span class="mord">3-opt</span></span></span></span></span></p><h3 id="_3-2-基于扰动强度的邻域" tabindex="-1"><a class="header-anchor" href="#_3-2-基于扰动强度的邻域"><span>3.2 基于扰动强度的邻域</span></a></h3><ul><li>小扰动：交换两个元素</li><li>中扰动：交换多个位置</li><li>大扰动：部分随机重构</li></ul><p>用于逐步打破局部最优结构。</p><h3 id="_3-3-基于结构变化的邻域-用于聚类-分区" tabindex="-1"><a class="header-anchor" href="#_3-3-基于结构变化的邻域-用于聚类-分区"><span>3.3 基于结构变化的邻域（用于聚类/分区）</span></a></h3><ul><li>移动一个对象到其他子集</li><li>移动两个对象</li><li>合并或拆分簇</li><li>随机重划分</li></ul><p>这些邻域更强调结构形态变化。</p><h3 id="_3-4-邻域多样化策略" tabindex="-1"><a class="header-anchor" href="#_3-4-邻域多样化策略"><span>3.4 邻域多样化策略</span></a></h3><ul><li><strong>同构邻域</strong>：相同操作但规模递增</li><li><strong>异构邻域</strong>：完全不同类型的操作</li><li><strong>问题特定邻域</strong>：结合业务逻辑的专用操作</li></ul><hr><h2 id="_4-vns-的主要变体" tabindex="-1"><a class="header-anchor" href="#_4-vns-的主要变体"><span>4. VNS 的主要变体</span></a></h2><h3 id="_4-1-bvns-basic-vns" tabindex="-1"><a class="header-anchor" href="#_4-1-bvns-basic-vns"><span>4.1 BVNS（Basic VNS）</span></a></h3><p>标准的 VNS 框架，最常见的基线版本。</p><h3 id="_4-2-rvns-random-vns" tabindex="-1"><a class="header-anchor" href="#_4-2-rvns-random-vns"><span>4.2 RVNS（Random VNS）</span></a></h3><p>只执行扰动，不执行局部搜索：</p><ul><li>优点：速度快</li><li>缺点：解质量一般</li></ul><p>适用于极大规模问题的粗略探索。</p><h3 id="_4-3-gvns-generalized-vns" tabindex="-1"><a class="header-anchor" href="#_4-3-gvns-generalized-vns"><span>4.3 GVNS（Generalized VNS）</span></a></h3><p>最强的增强型 VNS，包括：</p><ul><li>Shaking（扰动）</li><li>VND（Variable Neighborhood Descent，多邻域下降）</li><li>邻域递增策略</li></ul><p>通常是 VNS 在工业应用中的主力版本。</p><h3 id="_4-4-skewed-vns" tabindex="-1"><a class="header-anchor" href="#_4-4-skewed-vns"><span>4.4 Skewed VNS</span></a></h3><p>允许接受略差的解（类似模拟退火）帮助跳出“陷阱式”局部最优。</p><h3 id="_4-5-parallel-vns" tabindex="-1"><a class="header-anchor" href="#_4-5-parallel-vns"><span>4.5 Parallel VNS</span></a></h3><p>多个邻域/多个初始解并行搜索，适合多核与分布式环境。</p><hr><h2 id="_5-优点与缺点" tabindex="-1"><a class="header-anchor" href="#_5-优点与缺点"><span>5. 优点与缺点</span></a></h2><h3 id="_5-1-优点" tabindex="-1"><a class="header-anchor" href="#_5-1-优点"><span>5.1 优点</span></a></h3><ul><li><strong>结构简单</strong>：相比 GA/SA 参数极少</li><li><strong>跳出局部最优能力强</strong>：多邻域策略天然具备探索性</li><li><strong>高度可组合</strong>：能与 TS、SA、GA 任意结合</li><li><strong>适应性强</strong>：几乎适用于所有 NP-hard 问题</li></ul><h3 id="_5-2-缺点" tabindex="-1"><a class="header-anchor" href="#_5-2-缺点"><span>5.2 缺点</span></a></h3><ul><li><strong>邻域设计需要经验</strong>：设计不佳会影响效果</li><li><strong>局部搜索开销较大</strong>：尤其是复杂邻域下</li></ul><hr><h2 id="_6-应用场景" tabindex="-1"><a class="header-anchor" href="#_6-应用场景"><span>6. 应用场景</span></a></h2><h3 id="_6-1-车辆路径规划-vrp" tabindex="-1"><a class="header-anchor" href="#_6-1-车辆路径规划-vrp"><span>6.1 车辆路径规划（VRP）</span></a></h3><p>常用邻域：</p><ul><li>relocate</li><li>swap</li><li>2-opt</li><li>Or-opt</li></ul><p>可有效减少路线总长度并提升运行效率。</p><h3 id="_6-2-排班与调度-scheduling" tabindex="-1"><a class="header-anchor" href="#_6-2-排班与调度-scheduling"><span>6.2 排班与调度（Scheduling）</span></a></h3><p>可应用于：</p><ul><li>Job Shop</li><li>Flow Shop</li><li>Open Shop</li></ul><p>邻域如：</p><ul><li>工件交换</li><li>块移动</li><li>区段重排</li></ul><h3 id="_6-3-旅行商问题-tsp" tabindex="-1"><a class="header-anchor" href="#_6-3-旅行商问题-tsp"><span>6.3 旅行商问题（TSP）</span></a></h3><p>典型邻域组合：</p><ul><li>2-opt → Or-opt → 3-opt</li></ul><p>随着邻域增强跳出局部最优。</p><h3 id="_6-4-其他组合优化-np-hard" tabindex="-1"><a class="header-anchor" href="#_6-4-其他组合优化-np-hard"><span>6.4 其他组合优化（NP-hard）</span></a></h3><ul><li>背包问题（Knapsack）</li><li>最大割（Max-Cut）</li><li>SAT</li><li>网络设计与布线</li></ul><p>VNS 为这些问题提供了高效且鲁棒的近似最优解。</p><hr><h2 id="_7-tsp-示例-邻域序列" tabindex="-1"><a class="header-anchor" href="#_7-tsp-示例-邻域序列"><span>7. TSP 示例（邻域序列）</span></a></h2><h3 id="_7-1-邻域设置" tabindex="-1"><a class="header-anchor" href="#_7-1-邻域设置"><span>7.1 邻域设置</span></a></h3><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">N_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>: 2-opt</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">N_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>: Or-opt</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">N_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>: 3-opt</li></ul><h3 id="_7-2-搜索流程" tabindex="-1"><a class="header-anchor" href="#_7-2-搜索流程"><span>7.2 搜索流程</span></a></h3><ol><li>从 2-opt 找到局部最优</li><li>用 Or-opt 扰动跳出局部模式</li><li>用 3-opt 找到更优路线</li><li>若解被改进 → 回到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">N_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li>否则继续扩大邻域</li></ol><p>这种策略通过“逐级升级扰动”有效避免陷入局部最优。</p><hr><h2 id="_8-mermaid-流程图-vns-主流程" tabindex="-1"><a class="header-anchor" href="#_8-mermaid-流程图-vns-主流程"><span>8. Mermaid 流程图（VNS 主流程）</span></a></h2>`,75)),i(n,{id:"mermaid-480",code:"eJxN0EtOwzAQBuA9pxh50wXqgm0lQDTpIwV1QWGBrAq5yRBbjTKR7YpIDQfgHpyMkzB2QlvvbH/zz9gfFX3mWlkPL+kV8HqQYuN5L7YwHt/BVIpEEzkEUxtvVAWOqoM3VEMrtrFiGmHCdeihRlPqHVmuKbikwBYM3MLNYJNoU7Za7U1dTqDEGq3yCO2IPazfzUDTSGdSPFGuqg0qm+sJNJaKQx70aHCz6OZHkblwCjv0Hi14rXjEe/EV0Tyg7g1dBwspXpsiduTBzjmLmLOU4hkdP+Ry6mX/woukNXWQSRGQgesTzCJcHfni9/sH9v/tV+f2fUp/EFIew39TwwF/6ZdrQg=="}),s[1]||(s[1]=a("hr",null,null,-1)),s[2]||(s[2]=a("h2",{id:"_9-总结",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#_9-总结"},[a("span",null,"9. 总结")])],-1)),s[3]||(s[3]=a("p",null,"VNS 通过“系统改变邻域”机制获得强大的全局搜索能力：",-1)),s[4]||(s[4]=a("ul",null,[a("li",null,"多邻域组合 → 跳出局部最优"),a("li",null,"局部搜索增强 → 提升解质量"),a("li",null,"扰动强度逐渐增强 → 保证搜索的全面性")],-1)),s[5]||(s[5]=a("p",null,"它是现代优化算法中结构最清晰、扩展性最高的元启发式之一，广泛用于工业与学术领域。",-1))])}const d=t(m,[["render",h]]),g=JSON.parse('{"path":"/ai-ml/optimization/VNS.html","title":"可变邻域搜索 (VNS)","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","date":"2025-12-03T00:00:00.000Z","category":["智能优化算法"],"tag":["可变领域搜索"],"description":"可变邻域搜索 (VNS) 1. 概念简介 VNS（Variable Neighborhood Search，可变邻域搜索） 是一种元启发式算法，通过系统性地改变邻域结构来摆脱局部最优，从而找到更优解。 它依赖两个核心观察： 局部最优依赖邻域定义：不同邻域下的局部最优不同。 全局最优往往在某个邻域中是局部最优：系统探索多个邻域有助于发现全局更优解。 2....","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"可变邻域搜索 (VNS)\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-12-03T00:00:00.000Z\\",\\"dateModified\\":\\"2025-12-03T13:09:24.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Goat_Yang\\",\\"url\\":\\"../intro.html\\"}]}"],["meta",{"property":"og:url","content":"https://github.com/Yang-goat/MyBlog/ai-ml/optimization/VNS.html"}],["meta",{"property":"og:site_name","content":"Goat_Yang"}],["meta",{"property":"og:title","content":"可变邻域搜索 (VNS)"}],["meta",{"property":"og:description","content":"可变邻域搜索 (VNS) 1. 概念简介 VNS（Variable Neighborhood Search，可变邻域搜索） 是一种元启发式算法，通过系统性地改变邻域结构来摆脱局部最优，从而找到更优解。 它依赖两个核心观察： 局部最优依赖邻域定义：不同邻域下的局部最优不同。 全局最优往往在某个邻域中是局部最优：系统探索多个邻域有助于发现全局更优解。 2...."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-12-03T13:09:24.000Z"}],["meta",{"property":"article:tag","content":"可变领域搜索"}],["meta",{"property":"article:published_time","content":"2025-12-03T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-12-03T13:09:24.000Z"}]]},"git":{"createdTime":1764767364000,"updatedTime":1764767364000,"contributors":[{"name":"Yang-goat","username":"Yang-goat","email":"1700425119@qq.com","commits":1,"url":"https://github.com/Yang-goat"}]},"readingTime":{"minutes":4.23,"words":1270},"filePathRelative":"ai-ml/optimization/VNS.md","excerpt":"\\n<h2>1. 概念简介</h2>\\n<p><strong>VNS（Variable Neighborhood Search，可变邻域搜索）</strong> 是一种元启发式算法，通过系统性地改变邻域结构来摆脱局部最优，从而找到更优解。</p>\\n<p>它依赖两个核心观察：</p>\\n<ol>\\n<li><strong>局部最优依赖邻域定义</strong>：不同邻域下的局部最优不同。</li>\\n<li><strong>全局最优往往在某个邻域中是局部最优</strong>：系统探索多个邻域有助于发现全局更优解。</li>\\n</ol>\\n<hr>\\n<h2>2. 算法思想与框架</h2>\\n<h3>2.1 核心步骤</h3>","autoDesc":true}');export{d as comp,g as data};
