import{_ as n,c as p,d as a,e,r as m,o as i}from"./app-D3WFFSxQ.js";const l={};function r(o,s){const t=m("Mermaid");return i(),p("div",null,[s[0]||(s[0]=a('<h1 id="进化规划-ep" tabindex="-1"><a class="header-anchor" href="#进化规划-ep"><span>进化规划（EP）</span></a></h1><p>进化规划（Evolutionary Programming, EP）是<strong>进化算法家族</strong>中的重要成员，<br> 由美国学者 <strong>Lawrence J. Fogel</strong> 在 1960 年代提出，<br> 最初用于<strong>自动生成有限状态机</strong>，后来扩展为一种<strong>通用连续优化算法</strong>。</p><h2 id="一、算法基本思想" tabindex="-1"><a class="header-anchor" href="#一、算法基本思想"><span>一、算法基本思想</span></a></h2><div class="hint-container info"><p class="hint-container-title">生物启发</p><p>EP 模拟生物在进化过程中个体<strong>变异与选择</strong>的自然过程，<br> 核心思想是：</p><blockquote><p>“随机变异 + 竞争选择 = 逐步适应环境。”</p></blockquote></div><p>与 GA、ES 的主要区别：</p><table><thead><tr><th>对比项</th><th>遗传算法（GA）</th><th>进化策略（ES）</th><th>进化规划（EP）</th></tr></thead><tbody><tr><td>编码</td><td>二进制/实数</td><td>实数</td><td>实数</td></tr><tr><td>核心操作</td><td>交叉 + 变异</td><td>变异</td><td>变异</td></tr><tr><td>选择机制</td><td>适应度比例</td><td>排序/淘汰</td><td>随机竞争（tournament）</td></tr><tr><td>自适应性</td><td>弱</td><td>强（步长自适应）</td><td>强（变异参数自学习）</td></tr></tbody></table><hr><h2 id="二、算法流程图" tabindex="-1"><a class="header-anchor" href="#二、算法流程图"><span>二、算法流程图</span></a></h2>',8)),e(t,{id:"mermaid-102",code:"eJxdj0FKw0AUhvc9RciqXfQKim3aegB3QxYiiAtBEMGFCKEITlprAyk1SKvGSqOWNoIQNUl7mnlvklWv4HSmUOgwq/d/3/t5x6dnl0cnh+cX2oFR0MTbKxKgQwjacNfnQYcv3sySVi7vaBWSzXw+e8Cwy34/V3/u8seb3GpC3IN4bEq9Itkq0aHrQdpEt8Pmg2VK8SeB1ks+8bAfov0FrfdlauvKqUrHILz3jNSBqcOSkdqvckPmtXW/yrdqaxKpE51Pnlhs55aN7Q9Ry2kkl90rC8I/pN6muS61xhV6IThjTPws+uYJxekrDn2WRLvXEmsITBOAum0zEpoc7RdJtnDhNsaBxVIvC0ZmqfAPOnCvgw=="}),s[1]||(s[1]=a(`<h2 id="三、伪代码示例" tabindex="-1"><a class="header-anchor" href="#三、伪代码示例"><span>三、伪代码示例</span></a></h2><div class="language-" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>Algorithm EvolutionaryProgramming</span></span>
<span class="line"><span>Input: 种群规模 N, 最大代数 T</span></span>
<span class="line"><span>Output: 最优个体 best</span></span>
<span class="line"><span></span></span>
<span class="line"><span>1: 初始化种群 Xi 及其变异参数 σi</span></span>
<span class="line"><span>2: 计算每个个体的适应度 f(Xi)</span></span>
<span class="line"><span>3: for t = 1 to T do</span></span>
<span class="line"><span>4:     for each Xi do</span></span>
<span class="line"><span>5:         生成子代 Yi：</span></span>
<span class="line"><span>                Yi = Xi + σi * N(0, 1)</span></span>
<span class="line"><span>                σi&#39; = σi * exp(τ * N(0,1))</span></span>
<span class="line"><span>6:     计算所有子代适应度 f(Yi)</span></span>
<span class="line"><span>7:     将父代与子代合并</span></span>
<span class="line"><span>8:     使用随机锦标赛选择 N 个最优个体组成新种群</span></span>
<span class="line"><span>9: end for</span></span>
<span class="line"><span>10: 返回最优解 best</span></span></code></pre></div><h2 id="四、关键机制详解" tabindex="-1"><a class="header-anchor" href="#四、关键机制详解"><span>四、关键机制详解</span></a></h2><h3 id="_4-1-个体表示-representation" tabindex="-1"><a class="header-anchor" href="#_4-1-个体表示-representation"><span>4.1 个体表示（Representation）</span></a></h3><p>同ES：</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub><mo>=</mo><mo stretchy="false">(</mo><msub><mi mathvariant="bold">x</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>σ</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X_i=(\\mathbf{x}_i, \\sigma_i) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathbf">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><h3 id="_4-2-变异操作-mutation" tabindex="-1"><a class="header-anchor" href="#_4-2-变异操作-mutation"><span>4.2 变异操作（Mutation）</span></a></h3><p>EP 的搜索主要靠变异进行：</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi mathvariant="bold">x</mi><mo mathvariant="bold" lspace="0em" rspace="0em">′</mo></msup><mo>=</mo><mi mathvariant="bold">x</mi><mo>+</mo><mi>σ</mi><mo>⋅</mo><mi>N</mi><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\\mathbf{x&#39;} = \\mathbf{x}+\\sigma\\cdot N(0,1) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8019em;"></span><span class="mord"><span class="mord mathbf">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathbf mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathbf">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4445em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></p><p>并引入步长自适应机制：</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi>σ</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>=</mo><mi>σ</mi><mo>⋅</mo><msup><mi>e</mi><mrow><mi>τ</mi><mo>⋅</mo><mi>N</mi><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">\\sigma&#39; = \\sigma\\cdot e^{\\tau\\cdot N(0,1)} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8019em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4445em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.938em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.1132em;">τ</span><span class="mbin mtight">⋅</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="mopen mtight">(</span><span class="mord mtight">0</span><span class="mpunct mtight">,</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span></span></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span></span></span></span> 控制变异强度；</li><li>随代数变化，算法能自动调整搜索尺度。</li></ul><div class="hint-container tip"><p class="hint-container-title">提示</p><p>EP 的变异是多维高斯分布扰动，与 ES 十分类似，<br> 但它没有固定的(μ,λ)选择机制。</p></div><h3 id="_4-3-竞争选择-tournament-selection" tabindex="-1"><a class="header-anchor" href="#_4-3-竞争选择-tournament-selection"><span>4.3 竞争选择（Tournament Selection）</span></a></h3><p>EP 的选择方式独具特色——<strong>随机竞争选择</strong>：</p><ol><li>将父代和子代合并，共 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>N</mi></mrow><annotation encoding="application/x-tex">2N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 个体；</li><li>每个个体随机与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span> 个其他个体竞争（通常 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo>=</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">q=10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">10</span></span></span></span>）；</li><li>统计胜利次数，按胜场数排序；</li><li>选取前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 个作为下一代。</li></ol><p>这种机制具有<strong>强鲁棒性和全局搜索能力</strong>，可以避免早熟收敛。</p><h3 id="_4-4-自适应机制-self-adaptation" tabindex="-1"><a class="header-anchor" href="#_4-4-自适应机制-self-adaptation"><span>4.4 自适应机制（Self-Adaptation）</span></a></h3><p>每个个体的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span></span></span></span> 参数会随着进化自动调整：</p><ul><li>若大步长变异有助于提高适应度，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span></span></span></span> 会增大；</li><li>若小步长更有效，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span></span></span></span> 会逐步减小。</li></ul><p>这使得 EP 能自我学习搜索策略，无需人工调参。</p><h2 id="五、常见变种" tabindex="-1"><a class="header-anchor" href="#五、常见变种"><span>五、常见变种</span></a></h2><table><thead><tr><th>变体</th><th>说明</th></tr></thead><tbody><tr><td><strong>原始 EP</strong></td><td>用于有限状态机演化</td></tr><tr><td><strong>实数编码 EP (REP)</strong></td><td>适合连续优化问题</td></tr><tr><td><strong>自适应 EP (AEP)</strong></td><td>变异参数自动调整</td></tr><tr><td><strong>混合 EP</strong></td><td>与局部搜索算法结合（如 SA, PSO）</td></tr></tbody></table><h2 id="六、优缺点" tabindex="-1"><a class="header-anchor" href="#六、优缺点"><span>六、优缺点</span></a></h2><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>结构简单，参数少</td><td>收敛速度较慢</td></tr><tr><td>无需梯度信息</td><td>对维度高问题较慢</td></tr><tr><td>适应连续与噪声问题</td><td>参数自适应不易控制</td></tr><tr><td>竞争选择鲁棒性强</td><td>不适合离散编码问题</td></tr></tbody></table>`,25))])}const h=n(l,[["render",r]]),g=JSON.parse('{"path":"/ai-ml/optimization/EA/ep.html","title":"进化规划（EP）","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","date":"2025-10-18T00:00:00.000Z","order":3,"category":["智能优化算法"],"tag":["进化算法"],"description":"进化规划（EP） 进化规划（Evolutionary Programming, EP）是进化算法家族中的重要成员， 由美国学者 Lawrence J. Fogel 在 1960 年代提出， 最初用于自动生成有限状态机，后来扩展为一种通用连续优化算法。 一、算法基本思想 生物启发 EP 模拟生物在进化过程中个体变异与选择的自然过程， 核心思想是： “随机...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"进化规划（EP）\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-10-18T00:00:00.000Z\\",\\"dateModified\\":\\"2025-11-11T03:38:08.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Goat_Yang\\",\\"url\\":\\"../intro.html\\"}]}"],["meta",{"property":"og:url","content":"https://github.com/Yang-goat/MyBlog/ai-ml/optimization/EA/ep.html"}],["meta",{"property":"og:site_name","content":"Goat_Yang"}],["meta",{"property":"og:title","content":"进化规划（EP）"}],["meta",{"property":"og:description","content":"进化规划（EP） 进化规划（Evolutionary Programming, EP）是进化算法家族中的重要成员， 由美国学者 Lawrence J. Fogel 在 1960 年代提出， 最初用于自动生成有限状态机，后来扩展为一种通用连续优化算法。 一、算法基本思想 生物启发 EP 模拟生物在进化过程中个体变异与选择的自然过程， 核心思想是： “随机..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-11-11T03:38:08.000Z"}],["meta",{"property":"article:tag","content":"进化算法"}],["meta",{"property":"article:published_time","content":"2025-10-18T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-11-11T03:38:08.000Z"}]]},"git":{"createdTime":1761030494000,"updatedTime":1762832288000,"contributors":[{"name":"Yang-goat","username":"Yang-goat","email":"1700425119@qq.com","commits":2,"url":"https://github.com/Yang-goat"}]},"readingTime":{"minutes":2.97,"words":891},"filePathRelative":"ai-ml/optimization/EA/ep.md","excerpt":"\\n<p>进化规划（Evolutionary Programming, EP）是<strong>进化算法家族</strong>中的重要成员，<br>\\n由美国学者 <strong>Lawrence J. Fogel</strong> 在 1960 年代提出，<br>\\n最初用于<strong>自动生成有限状态机</strong>，后来扩展为一种<strong>通用连续优化算法</strong>。</p>\\n<h2>一、算法基本思想</h2>\\n<div class=\\"hint-container info\\">\\n<p class=\\"hint-container-title\\">生物启发</p>\\n<p>EP 模拟生物在进化过程中个体<strong>变异与选择</strong>的自然过程，<br>\\n核心思想是：</p>\\n<blockquote>\\n<p>“随机变异 + 竞争选择 = 逐步适应环境。”</p>\\n</blockquote>\\n</div>","autoDesc":true}');export{h as comp,g as data};
